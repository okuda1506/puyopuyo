<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ぷよゲー</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Mochiy+Pop+One&display=swap');
        /* スクロールを禁止し、画面全体に表示 */
        html, body {
            height: 100%;
            overflow: hidden; 
        }
        body {
            font-family: 'Mochiy+Pop+One', sans-serif;
            touch-action: none; /* ダブルタップによるズームを無効化 */
        }
        /* ゲームキャンバスのピクセルをくっきり表示 */
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body class="bg-blue-100">

    <!-- 全画面コンテナ -->
    <div class="w-full h-full mx-auto bg-white flex flex-col p-2">
        
        <!-- ヘッダー情報エリア -->
        <div class="flex-shrink-0">
            <h1 class="text-2xl font-bold text-center text-blue-600">ぷよゲー</h1>
            <div class="flex justify-around items-center gap-2 my-1">
                <div class="text-center">
                    <h2 class="text-sm text-gray-600">スコア</h2>
                    <p id="score" class="text-2xl font-bold text-yellow-500">0</p>
                </div>
                <div class="text-center">
                    <h2 class="text-sm text-gray-600">れんさ</h2>
                    <p id="chain" class="text-2xl font-bold text-pink-500">0</p>
                </div>
                <div class="text-center">
                    <h2 class="text-sm text-gray-600">つぎのぷよ</h2>
                    <canvas id="next-puyo-canvas" class="bg-gray-100 rounded-lg border border-gray-300"></canvas>
                </div>
            </div>
        </div>

        <!-- ゲーム画面エリア (可変) -->
        <div class="relative w-full max-w-xs mx-auto flex-grow my-2 flex items-center justify-center">
             <div class="relative w-full h-full">
                <canvas id="game-canvas" class="bg-gray-800 rounded-lg border-2 border-gray-500 absolute top-0 left-0"></canvas>
                <div id="game-over" class="absolute inset-0 bg-black bg-opacity-70 rounded-lg flex-col justify-center items-center text-white text-3xl font-bold hidden text-center p-4">
                    <p>ゲームオーバー</p>
                    <p class="text-base mt-2">下のボタンでリスタート</p>
                </div>
             </div>
        </div>

        <!-- 操作エリア -->
        <div class="flex-shrink-0 max-w-xs mx-auto w-full">
            <div class="grid grid-cols-3 gap-2 items-center mb-2">
                <button id="left-btn" class="bg-blue-500 text-white font-bold py-3 rounded-lg shadow-md active:bg-blue-700 text-xl">←</button>
                <button id="down-btn" class="bg-blue-500 text-white font-bold py-3 rounded-lg shadow-md active:bg-blue-700 text-xl">↓</button>
                <button id="right-btn" class="bg-blue-500 text-white font-bold py-3 rounded-lg shadow-md active:bg-blue-700 text-xl">→</button>
                <button id="rotate-left-btn" class="bg-green-500 text-white font-bold py-3 rounded-lg shadow-md active:bg-green-700 col-span-1 text-xl">左回転</button>
                <button id="rotate-right-btn" class="bg-green-500 text-white font-bold py-3 rounded-lg shadow-md active:bg-green-700 col-span-2 text-xl">右回転</button>
            </div>

            <button id="start-button" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 rounded-lg shadow-lg text-xl transition duration-200">
                ゲームスタート
            </button>
        </div>
    </div>

    <script>
        // DOM要素の取得
        const canvas = document.getElementById('game-canvas');
        const nextCanvas = document.getElementById('next-puyo-canvas');
        const scoreEl = document.getElementById('score');
        const chainEl = document.getElementById('chain');
        const startButton = document.getElementById('start-button');
        const gameOverEl = document.getElementById('game-over');

        const ctx = canvas.getContext('2d');
        const nextCtx = nextCanvas.getContext('2d');

        // ゲーム設定
        const COLS = 6;
        const ROWS = 13;
        const HIDDEN_ROWS = 1; // 画面上部に見えない行
        
        // Canvasの解像度をコンテナのサイズに合わせて動的に調整
        function resizeCanvas() {
            const gameContainer = canvas.parentElement;
            const containerWidth = gameContainer.clientWidth;
            const containerHeight = gameContainer.clientHeight;

            // アスペクト比 (幅:高さ = 6:12)
            const aspectRatio = COLS / (ROWS - HIDDEN_ROWS);

            let canvasWidth, canvasHeight;

            if (containerWidth / containerHeight > aspectRatio) {
                // コンテナが横長の場合、高さを基準に合わせる
                canvasHeight = containerHeight;
                canvasWidth = canvasHeight * aspectRatio;
            } else {
                // コンテナが縦長の場合、幅を基準に合わせる
                canvasWidth = containerWidth;
                canvasHeight = canvasWidth / aspectRatio;
            }
            
            // canvasの表示サイズを設定
            canvas.style.width = `${canvasWidth}px`;
            canvas.style.height = `${canvasHeight}px`;

            // canvasの描画解像度を設定
            const blockSize = canvasWidth / COLS;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // 描画スケールを設定
            ctx.scale(blockSize, blockSize);
        }
        
        // 次のぷよCanvasの設定
        const NEXT_BLOCK_SIZE = 20;
        nextCanvas.width = NEXT_BLOCK_SIZE * 4;
        nextCanvas.height = NEXT_BLOCK_SIZE * 4;
        nextCtx.scale(NEXT_BLOCK_SIZE, NEXT_BLOCK_SIZE);


        const PUYO_COLORS = {
            1: '#ef4444', // 赤
            2: '#22c55e', // 緑
            3: '#3b82f6', // 青
            4: '#eab308', // 黄
            5: '#a855f7', // 紫
        };
        const NUM_PUYO_TYPES = Object.keys(PUYO_COLORS).length;

        // ゲームの状態
        let grid;
        let currentPuyo;
        let nextPuyo;
        let score;
        let chainCount;
        let isGameOver;
        let fallInterval;
        let fallSpeed;
        let isCheckingChain = false; // 連鎖チェック中フラグ

        // ぷよクラス
        class Puyo {
            constructor(puyoCtx) {
                this.ctx = puyoCtx;
                this.reset();
            }

            // 新しいぷよを生成
            spawn() {
                this.axis = { x: 2, y: 0 };
                this.center = { x: 2, y: -1 }; // 軸ぷよが(2,0)に来るように中心を調整
                this.color = this.randomizeColor();
                this.subColor = this.randomizeColor();
                this.rotation = 0; // 0:上, 1:右, 2:下, 3:左
            }
            
            // ぷよをリセット
            reset() {
                this.axis = { x: 0, y: 0 };
                this.center = { x: 0, y: 0 };
                this.color = 0;
                this.subColor = 0;
            }

            // ぷよの色をランダムに決定
            randomizeColor() {
                return Math.floor(Math.random() * NUM_PUYO_TYPES) + 1;
            }

            // ぷよを描画
            draw() {
                // 中心ぷよ
                this.ctx.fillStyle = PUYO_COLORS[this.color];
                this.drawPuyo(this.center.x, this.center.y - HIDDEN_ROWS);

                // 軸ぷよ
                this.ctx.fillStyle = PUYO_COLORS[this.subColor];
                this.drawPuyo(this.axis.x, this.axis.y - HIDDEN_ROWS);
            }
            
            // 1つのぷよを描画するヘルパー関数
            drawPuyo(x, y) {
                if (this.ctx.canvas.id === 'game-canvas' && y < 0) return; // ゲーム画面外は描画しない

                this.ctx.beginPath();
                this.ctx.arc(x + 0.5, y + 0.5, 0.45, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // 目玉を描画
                this.ctx.fillStyle = 'white';
                this.ctx.beginPath();
                this.ctx.arc(x + 0.6, y + 0.4, 0.15, 0, 2 * Math.PI);
                this.ctx.fill();
                this.ctx.fillStyle = 'black';
                this.ctx.beginPath();
                this.ctx.arc(x + 0.65, y + 0.45, 0.07, 0, 2 * Math.PI);
                this.ctx.fill();
            }

            // ぷよを移動
            move(dx, dy) {
                this.center.x += dx;
                this.center.y += dy;
                this.axis.x += dx;
                this.axis.y += dy;
            }

            // ぷよを回転
            rotate(direction) {
                const prevRotation = this.rotation;
                
                const dx = this.axis.x - this.center.x;
                const dy = this.axis.y - this.center.y;
                
                let newAxisX, newAxisY;
                if (direction === 1) { // 右回転
                    newAxisX = this.center.x - dy;
                    newAxisY = this.center.y + dx;
                } else { // 左回転
                    newAxisX = this.center.x + dy;
                    newAxisY = this.center.y - dx;
                }

                const originalAxisX = this.axis.x;
                const originalAxisY = this.axis.y;
                this.axis.x = newAxisX;
                this.axis.y = newAxisY;
                
                // 壁や他のぷよにぶつかった場合の補正
                if (!isValidMove(this.axis.x, this.axis.y) || !isValidMove(this.center.x, this.center.y)) {
                    // 横にずらして試す
                    const originalCenterX = this.center.x;
                    const shift = this.axis.x < 0 ? 1 : (this.axis.x >= COLS ? -1 : 0);
                    this.move(shift, 0);

                    if (!isValidMove(this.axis.x, this.axis.y) || !isValidMove(this.center.x, this.center.y)) {
                       // 戻す
                       this.move(originalCenterX - this.center.x, 0); // 横移動を戻す
                       this.axis.x = originalAxisX; // 回転も戻す
                       this.axis.y = originalAxisY;
                    } else {
                        this.rotation = (this.rotation + direction + 4) % 4;
                    }
                } else {
                     this.rotation = (this.rotation + direction + 4) % 4;
                }
            }
        }

        // ゲームの初期化
        function init() {
            resizeCanvas();
            grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            score = 0;
            chainCount = 0;
            isGameOver = false;
            fallSpeed = 800;
            updateScoreDisplay();

            currentPuyo = new Puyo(ctx);
            currentPuyo.spawn();
            
            nextPuyo = new Puyo(nextCtx);
            nextPuyo.spawn();
            drawNextPuyo();

            gameOverEl.style.display = 'none';
            startButton.textContent = 'リスタート';

            if (fallInterval) clearInterval(fallInterval);
            fallInterval = setInterval(gameLoop, fallSpeed);
            draw();
        }

        // ゲームループ
        function gameLoop() {
            if (isGameOver || isCheckingChain) return;

            // ぷよを1段下に落とす
            if (canMove(0, 1)) {
                currentPuyo.move(0, 1);
            } else {
                // 設置
                lockPuyo();
                // 新しいぷよを生成
                currentPuyo.color = nextPuyo.color;
                currentPuyo.subColor = nextPuyo.subColor;
                currentPuyo.spawn(); // 新しい位置に
                
                nextPuyo.spawn();
                drawNextPuyo();
                
                // ゲームオーバーチェック
                if (!canMove(0,0)) {
                    gameOver();
                    return;
                }
                
                // 連鎖処理を開始
                isCheckingChain = true;
                chainCount = 0;
                checkAllChains();
            }
            draw();
        }
        
        // 連鎖処理のメイン関数
        async function checkAllChains() {
            let foundMatch = false;
            do {
                await sleep(300); // ぷよが消える演出のための待機
                const clearedPuyos = findAndClearMatches();
                
                if (clearedPuyos > 0) {
                    foundMatch = true;
                    chainCount++;
                    calculateScore(clearedPuyos, chainCount);
                    updateScoreDisplay();
                    draw();
                    
                    await sleep(300); // ぷよが落ちる演出のための待機
                    applyGravity();
                    draw();
                } else {
                    foundMatch = false;
                }
            } while (foundMatch);
            
            isCheckingChain = false; // 連鎖処理終了
        }

        // ぷよをグリッドに固定
        function lockPuyo() {
            if (currentPuyo.center.y >= 0) grid[currentPuyo.center.y][currentPuyo.center.x] = currentPuyo.color;
            if (currentPuyo.axis.y >= 0) grid[currentPuyo.axis.y][currentPuyo.axis.x] = currentPuyo.subColor;
        }

        // ぷよが指定方向に移動可能かチェック
        function canMove(dx, dy) {
            const nextCenterX = currentPuyo.center.x + dx;
            const nextCenterY = currentPuyo.center.y + dy;
            const nextAxisX = currentPuyo.axis.x + dx;
            const nextAxisY = currentPuyo.axis.y + dy;

            return isValidMove(nextCenterX, nextCenterY) && isValidMove(nextAxisX, nextAxisY);
        }

        // 指定された座標が有効か（グリッド範囲内で空か）チェック
        function isValidMove(x, y) {
            return x >= 0 && x < COLS && y < ROWS && (y < 0 || grid[y][x] === 0);
        }
        
        // 4つ以上繋がったぷよを探して消す
        function findAndClearMatches() {
            const toClear = [];
            const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
            let totalCleared = 0;

            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (grid[y][x] !== 0 && !visited[y][x]) {
                        const color = grid[y][x];
                        const connected = [];
                        const queue = [{ x, y }];
                        visited[y][x] = true;

                        while (queue.length > 0) {
                            const { x: cx, y: cy } = queue.shift();
                            connected.push({ x: cx, y: cy });

                            const neighbors = [
                                { x: cx, y: cy - 1 }, // 上
                                { x: cx, y: cy + 1 }, // 下
                                { x: cx - 1, y: cy }, // 左
                                { x: cx + 1, y: cy }  // 右
                            ];

                            for (const n of neighbors) {
                                if (n.x >= 0 && n.x < COLS && n.y >= 0 && n.y < ROWS &&
                                    grid[n.y][n.x] === color && !visited[n.y][n.x]) {
                                    visited[n.y][n.x] = true;
                                    queue.push(n);
                                }
                            }
                        }

                        if (connected.length >= 4) {
                            toClear.push(...connected);
                        }
                    }
                }
            }

            if (toClear.length > 0) {
                totalCleared = toClear.length;
                toClear.forEach(({ x, y }) => {
                    grid[y][x] = 0;
                });
            }
            return totalCleared;
        }
        
        // 消えたぷよの上に浮いているぷよを落とす
        function applyGravity() {
            for (let x = 0; x < COLS; x++) {
                let emptyRow = ROWS - 1;
                for (let y = ROWS - 1; y >= 0; y--) {
                    if (grid[y][x] !== 0) {
                        if (y !== emptyRow) {
                            grid[emptyRow][x] = grid[y][x];
                            grid[y][x] = 0;
                        }
                        emptyRow--;
                    }
                }
            }
        }
        
        // スコア計算
        function calculateScore(clearedCount, chain) {
            const chainBonus = [0, 8, 16, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 480, 512];
            const bonus = chainBonus[Math.min(chain, chainBonus.length - 1)];
            score += clearedCount * 10 * (bonus === 0 ? 1 : bonus);
        }

        // ゲームオーバー処理
        function gameOver() {
            isGameOver = true;
            clearInterval(fallInterval);
            gameOverEl.style.display = 'flex';
        }

        // 描画処理
        function draw() {
            // 背景をクリア
            const currentScale = canvas.width / COLS;
            ctx.clearRect(0, 0, canvas.width / currentScale, canvas.height / currentScale);
            
            drawGrid();
            if (!isGameOver && currentPuyo) {
                currentPuyo.draw();
            }
        }

        // グリッド上のぷよを描画
        function drawGrid() {
            for (let y = HIDDEN_ROWS; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (grid[y][x] !== 0) {
                        ctx.fillStyle = PUYO_COLORS[grid[y][x]];
                        const puyo = new Puyo(ctx);
                        puyo.drawPuyo(x, y - HIDDEN_ROWS);
                    }
                }
            }
        }
        
        // 次のぷよを描画
        function drawNextPuyo() {
            nextCtx.clearRect(0, 0, 4, 4);
            // 中心ぷよ
            nextCtx.fillStyle = PUYO_COLORS[nextPuyo.color];
            nextPuyo.drawPuyo(1.5, 2);
            // 軸ぷよ
            nextCtx.fillStyle = PUYO_COLORS[nextPuyo.subColor];
            nextPuyo.drawPuyo(1.5, 1);
        }

        // スコア表示を更新
        function updateScoreDisplay() {
            scoreEl.textContent = score;
            chainEl.textContent = `${chainCount} れんさ`;
        }
        
        // sleep関数
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // キーボード操作
        document.addEventListener('keydown', (e) => {
            if (isGameOver || isCheckingChain) return;

            if (e.key === 'ArrowLeft') { // 左
                if (canMove(-1, 0)) currentPuyo.move(-1, 0);
            } else if (e.key === 'ArrowRight') { // 右
                if (canMove(1, 0)) currentPuyo.move(1, 0);
            } else if (e.key === 'ArrowDown') { // 下
                if (canMove(0, 1)) {
                    currentPuyo.move(0, 1);
                    score += 1; // 高速落下ボーナス
                    updateScoreDisplay();
                } else {
                    gameLoop(); // 即座に次の処理へ
                }
            } else if (e.key === 'z' || e.key === 'Z') { // 左回転
                currentPuyo.rotate(-1);
            } else if (e.key === 'x' || e.key === 'X') { // 右回転
                currentPuyo.rotate(1);
            }
            draw();
        });
        
        // ボタン操作
        document.getElementById('left-btn').addEventListener('click', () => handleMove(-1, 0));
        document.getElementById('right-btn').addEventListener('click', () => handleMove(1, 0));
        document.getElementById('down-btn').addEventListener('click', () => handleMove(0, 1, true));
        document.getElementById('rotate-left-btn').addEventListener('click', () => handleRotate(-1));
        document.getElementById('rotate-right-btn').addEventListener('click', () => handleRotate(1));
        
        function handleMove(dx, dy, isDown = false) {
             if (isGameOver || isCheckingChain) return;
             if (canMove(dx, dy)) {
                currentPuyo.move(dx, dy);
                if (isDown) {
                    score += 1;
                    updateScoreDisplay();
                }
             } else if (isDown) {
                gameLoop();
             }
             draw();
        }
        
        function handleRotate(direction) {
            if (isGameOver || isCheckingChain) return;
            currentPuyo.rotate(direction);
            draw();
        }

        // ゲームスタートボタン
        startButton.addEventListener('click', init);
        
        // ウィンドウリサイズ時の処理
        window.addEventListener('resize', () => {
            if(!isGameOver) {
                resizeCanvas();
                draw();
            }
        });

        // 初回描画
        resizeCanvas();
    </script>
</body>
</html>
